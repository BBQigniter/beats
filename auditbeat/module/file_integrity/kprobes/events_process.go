package kprobes

import (
	"context"
	"errors"
	"path/filepath"

	"golang.org/x/sys/unix"
)

// TODO(panosk) finalise the Emitter interface according to our needs
type Emitter interface {
	Emit(ePath string, pid uint32, op uint32) error
}

type eventProcessor interface {
	process(ctx context.Context, pe *ProbeEvent) error
}

type eProcessor struct {
	p pathTraverser
	e Emitter
	d *dEntryCache
}

func newEventProcessor(p pathTraverser, e Emitter) *eProcessor {
	return &eProcessor{
		p: p,
		e: e,
		d: newDirEntryCache(),
	}
}

func (e *eProcessor) process(ctx context.Context, pe *ProbeEvent) error {
	// after processing return the probe event to the pool
	defer releaseProbeEvent(pe)

	switch {
	case pe.MaskMonitor == 1:
		// Monitor events are only generated by our own pathTraverser.AddPathToMonitor or
		// pathTraverser.WalkAsync

		entry := e.d.Get(dKey{
			Ino:      pe.FileIno,
			DevMajor: pe.FileDevMajor,
			DevMinor: pe.FileDevMinor,
		})

		if entry != nil {
			// entry already exists, no need to add
			return nil
		}

		parentEntry := e.d.Get(dKey{
			Ino:      pe.ParentIno,
			DevMajor: pe.ParentDevMajor,
			DevMinor: pe.ParentDevMinor,
		})

		if parentEntry == nil {

			// if parentEntry does not exist then this has to come from
			// an event caused by pathTraverser.AddPathToMonitor, Ack this and get the fullpath
			// of this root dirEntry.
			fullPath, ack := e.p.Ack(ctx, pe.FileIno, pe.FileDevMajor, pe.FileDevMinor, pe.FileName)

			if !ack {
				return nil
			}

			entry = &dEntry{
				Name:     fullPath,
				Ino:      pe.FileIno,
				DevMajor: pe.FileDevMajor,
				DevMinor: pe.FileDevMinor,
			}
		} else {

			// parentEntry exists so this event can be caused either by pathTraverser.AddPathToMonitor or
			// pathTraverser.WalkAsync.

			entry = &dEntry{
				Name:     pe.FileName,
				Ino:      pe.FileIno,
				DevMajor: pe.FileDevMajor,
				DevMinor: pe.FileDevMinor,
			}

			entry.Parent = parentEntry

			// if ChildrenEmitOnMonitor is set this means that this event is caused by pathTraverser.WalkAsync
			// invoked by a MoveTo event, and thus we need to emit the newly created entries.
			if parentEntry.MonitorReason != nil {
				entry.MonitorReason = parentEntry.MonitorReason
			}
		}

		e.d.Add(entry)

		if entry.MonitorReason == nil {
			return nil
		}

		return e.e.Emit(entry.Path(), entry.MonitorReason.tid, unix.IN_MOVED_TO)

	case pe.MaskCreate == 1:
		parentEntry := e.d.Get(dKey{
			Ino:      pe.ParentIno,
			DevMajor: pe.ParentDevMajor,
			DevMinor: pe.ParentDevMinor,
		})

		if parentEntry == nil {
			return nil
		}

		entry := &dEntry{
			Parent:   parentEntry,
			Children: nil,
			Name:     pe.FileName,
			Ino:      pe.FileIno,
			DevMajor: pe.FileDevMajor,
			DevMinor: pe.FileDevMinor,
		}

		parentEntry.AddChild(entry)
		e.d.Add(entry)

		return e.e.Emit(entry.Path(), pe.Meta.TID, unix.IN_CREATE)

	case pe.MaskModify == 1:
		entry := e.d.Get(dKey{
			Ino:      pe.FileIno,
			DevMajor: pe.FileDevMajor,
			DevMinor: pe.FileDevMinor,
		})

		if entry == nil {
			return nil
		}

		return e.e.Emit(entry.Path(), pe.Meta.TID, unix.IN_MODIFY)

	case pe.MaskAttrib == 1:
		entry := e.d.Get(dKey{
			Ino:      pe.FileIno,
			DevMajor: pe.FileDevMajor,
			DevMinor: pe.FileDevMinor,
		})

		if entry == nil {
			return nil
		}

		return e.e.Emit(entry.Path(), pe.Meta.TID, unix.IN_ATTRIB)

	case pe.MaskMoveFrom == 1:
		entry := e.d.MoveFrom(uint64(pe.Meta.TID), dKey{
			Ino:      pe.ParentIno,
			DevMajor: pe.ParentDevMajor,
			DevMinor: pe.ParentDevMinor,
		}, pe.FileName)

		if entry == nil {
			return nil
		}

		return e.e.Emit(entry.Path(), pe.Meta.TID, unix.IN_MOVED_FROM)

	case pe.MaskMoveTo == 1:
		parentEntry := e.d.Get(dKey{
			Ino:      pe.ParentIno,
			DevMajor: pe.ParentDevMajor,
			DevMinor: pe.ParentDevMinor,
		})

		if parentEntry == nil {
			// if parentEntry is nil then this move event is not
			// for a directory we monitor
			e.d.MoveClear(uint64(pe.Meta.TID))
			return nil
		}

		moved, err := e.d.MoveTo(uint64(pe.Meta.TID), parentEntry, pe.FileName, func(path string) error {
			return e.e.Emit(path, pe.Meta.TID, unix.IN_MOVED_TO)
		})
		if err != nil {
			return err
		}
		if moved {
			return nil
		}

		newEntryPath := filepath.Join(parentEntry.Path(), pe.FileName)
		parentEntry.MonitorReason = &Reason{
			tid:       pe.Meta.TID,
			timestamp: pe.Meta.Timestamp,
		}
		e.p.WalkAsync(newEntryPath)

		return nil

	case pe.MaskDelete == 1:
		parentEntry := e.d.Get(dKey{
			Ino:      pe.ParentIno,
			DevMajor: pe.ParentDevMajor,
			DevMinor: pe.ParentDevMinor,
		})

		if parentEntry == nil {
			return nil
		}

		entry := parentEntry.GetChild(pe.FileName)
		if entry == nil {
			return nil
		}

		e.d.Remove(entry)

		if err := e.e.Emit(entry.Path(), pe.Meta.TID, unix.IN_DELETE); err != nil {
			return err
		}

		entry.Release()
		entry = nil

		return nil
	default:
		return errors.New("unknown event type")
	}
}
